name: Daily Archive Update

on:
  schedule:
    - cron: "12 12 * * *" # 12:12 UTC daily (21:12 JST fixed)
    - cron: "32 12 * * *" # 12:32 UTC missed-run check
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: daily-archive-update
  cancel-in-progress: true

jobs:
  run-daily:
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.schedule == '12 12 * * *' }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Generate daily_input.env from Bitget read-only snapshot
        env:
          BITGET_API_KEY: ${{ secrets.BITGET_API_KEY }}
          BITGET_API_SECRET: ${{ secrets.BITGET_API_SECRET }}
          BITGET_API_PASSPHRASE: ${{ secrets.BITGET_API_PASSPHRASE }}
        run: |
          python scripts/generate_daily_input_env.py

      - name: Run daily log update
        env:
          DRY_RUN: "0"
          DAILY_CUTOFF_JST: "09:00"
        run: |
          python scripts/run_daily.py

      - name: Generate BTCSIGNAL daily proof (HOLD/CASH)
        run: |
          python scripts/btcsignal_daily.py

      - name: Export BTCSIGNAL live decision log (seed excluded)
        run: |
          python scripts/export_btcsignal_live_log.py

      - name: Ensure Live Testing baseline (2026-02-26)
        run: |
          python scripts/ensure_live_test_baseline.py --start-date-jst 2026-02-26

      - name: Execute Bitget from BTCSIGNAL (DRY_RUN first)
        continue-on-error: true
        env:
          DRY_RUN: ${{ vars.BITGET_EXEC_DRY_RUN || '1' }}
          BITGET_EXECUTE_ENABLED: ${{ vars.BITGET_EXECUTE_ENABLED || '0' }}
          BITGET_SYMBOL: ${{ vars.BITGET_SYMBOL || 'BTC/USDT' }}
          MIN_TRADE_USD: ${{ vars.MIN_TRADE_USD || '5' }}
          MIN_BTC_QTY: ${{ vars.MIN_BTC_QTY || '0.00001' }}
          MAX_NOTIONAL_USD: ${{ vars.MAX_NOTIONAL_USD || '10' }}
          EXECUTE_USDT_FRACTION: ${{ vars.EXECUTE_USDT_FRACTION || '0.1' }}
          EXECUTE_BTC_FRACTION: ${{ vars.EXECUTE_BTC_FRACTION || '0.1' }}
          ALLOW_LIVE: ${{ vars.ALLOW_LIVE || 'NO' }}
          BITGET_API_KEY: ${{ secrets.BITGET_API_KEY }}
          BITGET_API_SECRET: ${{ secrets.BITGET_API_SECRET }}
          BITGET_API_PASSPHRASE: ${{ secrets.BITGET_API_PASSPHRASE }}
        run: |
          python scripts/bitget_execute_from_btcsignal.py

      - name: Notify Discord BTCSIGNAL proof
        continue-on-error: true
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL || secrets.DISCORD1 || secrets.DISCORD }}
        run: |
          python scripts/notify_btcsignal_discord.py --ops-status PASS

      - name: Notify Discord X draft (#x-posts)
        continue-on-error: true
        env:
          DISCORD_X_WEBHOOK_URL: ${{ secrets.DISCORD_X_WEBHOOK_URL }}
          DASHBOARD_URL: ${{ vars.DASHBOARD_URL || 'https://btcsignal.org/' }}
        run: |
          python scripts/notify_x_draft_discord.py --ops-status PASS

      - name: Commit and push if changed
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git add log.json logs/*.json data/live_portfolio_snapshot.json data/live_pnl_cache.json btcsignal_log.json btcsignal_log_live.json
          [ -f data/live_test_baseline.json ] && git add data/live_test_baseline.json || true
          [ -f data/btcsignal_execution_log.csv ] && git add data/btcsignal_execution_log.csv || true
          [ -f data/btcsignal_execute_state.json ] && git add data/btcsignal_execute_state.json || true

          if git diff --cached --quiet; then
            echo "No changes to commit."
            exit 0
          fi

          git commit -m "chore: daily log update"
          git push

      - name: Collect run context
        if: ${{ always() }}
        run: |
          echo "EXPECTED_DATE_UTC=$(date -u +%F)" >> "$GITHUB_ENV"
          python - <<'PY'
          import json
          from pathlib import Path
          p = Path("log.json")
          latest_date = "UNAVAILABLE"
          latest_updated = "UNAVAILABLE"
          try:
              j = json.loads(p.read_text(encoding="utf-8"))
              latest = j.get("latest") or {}
              latest_date = str(latest.get("date") or "UNAVAILABLE")
              latest_updated = str(latest.get("updated_at_utc") or "UNAVAILABLE")
          except Exception:
              pass
          with open(".run_ctx.env", "w", encoding="utf-8") as f:
              f.write(f"ACTUAL_LATEST_DATE={latest_date}\n")
              f.write(f"LATEST_UPDATED_AT_UTC={latest_updated}\n")
          PY
          cat .run_ctx.env >> "$GITHUB_ENV"

      - name: Notify Discord on daily run failure
        if: ${{ failure() }}
        continue-on-error: true
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL || secrets.DISCORD1 || secrets.DISCORD }}
          RUN_ID: ${{ github.run_id }}
          WORKFLOW_NAME: ${{ github.workflow }}
          JOB_NAME: run-daily
        run: |
          python - <<'PY'
          import json, os, urllib.request
          webhook = os.environ.get("DISCORD_WEBHOOK_URL", "").strip()
          if not webhook:
              raise SystemExit(0)
          msg = (
              f"ðŸš¨ Daily run failed\n"
              f"workflow={os.environ.get('WORKFLOW_NAME')}\n"
              f"job={os.environ.get('JOB_NAME')}\n"
              f"run_id={os.environ.get('RUN_ID')}\n"
              f"expected_date_utc={os.environ.get('EXPECTED_DATE_UTC','UNAVAILABLE')}\n"
              f"actual_latest_date={os.environ.get('ACTUAL_LATEST_DATE','UNAVAILABLE')}\n"
              f"latest_updated_at_utc={os.environ.get('LATEST_UPDATED_AT_UTC','UNAVAILABLE')}\n"
              f"reason=daily_run_failed"
          )
          data = json.dumps({"content": msg}).encode("utf-8")
          req = urllib.request.Request(webhook, data=data, headers={"Content-Type": "application/json"}, method="POST")
          urllib.request.urlopen(req, timeout=10).read()
          PY

  missed-run-check:
    if: ${{ github.event_name == 'schedule' && github.event.schedule == '32 12 * * *' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Verify latest signal/proof date (UTC)
        id: verify
        run: |
          EXPECTED_DATE_UTC="$(date -u +%F)"
          echo "EXPECTED_DATE_UTC=$EXPECTED_DATE_UTC" >> "$GITHUB_ENV"
          set +e
          python - <<'PY'
          import json, os
          from pathlib import Path
          expected = os.environ.get("EXPECTED_DATE_UTC", "").strip()
          p = Path("log.json")
          latest_date = "UNAVAILABLE"
          latest_updated = "UNAVAILABLE"
          try:
              j = json.loads(p.read_text(encoding="utf-8"))
              latest = j.get("latest") or {}
              latest_date = str(latest.get("date") or "UNAVAILABLE")
              latest_updated = str(latest.get("updated_at_utc") or "UNAVAILABLE")
          except Exception:
              pass
          with open(".missed_ctx.env", "w", encoding="utf-8") as f:
              f.write(f"ACTUAL_LATEST_DATE={latest_date}\n")
              f.write(f"LATEST_UPDATED_AT_UTC={latest_updated}\n")
          if not expected:
              print("ERROR: EXPECTED_DATE_UTC is missing")
              raise SystemExit(1)
          if latest_date != expected:
              raise SystemExit(1)
          PY
          rc=$?
          set -e
          cat .missed_ctx.env >> "$GITHUB_ENV"
          exit $rc

      - name: Notify Discord on missed run
        if: ${{ failure() }}
        continue-on-error: true
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL || secrets.DISCORD1 || secrets.DISCORD }}
          RUN_ID: ${{ github.run_id }}
          WORKFLOW_NAME: ${{ github.workflow }}
          JOB_NAME: missed-run-check
        run: |
          python - <<'PY'
          import json, os, urllib.request
          webhook = os.environ.get("DISCORD_WEBHOOK_URL", "").strip()
          if not webhook:
              raise SystemExit(0)
          msg = (
              f"âš ï¸ Missed daily signal/proof update\n"
              f"workflow={os.environ.get('WORKFLOW_NAME')}\n"
              f"job={os.environ.get('JOB_NAME')}\n"
              f"run_id={os.environ.get('RUN_ID')}\n"
              f"expected_date_utc={os.environ.get('EXPECTED_DATE_UTC','UNAVAILABLE')}\n"
              f"actual_latest_date={os.environ.get('ACTUAL_LATEST_DATE','UNAVAILABLE')}\n"
              f"latest_updated_at_utc={os.environ.get('LATEST_UPDATED_AT_UTC','UNAVAILABLE')}\n"
              f"reason=missed_run_check_failed"
          )
          data = json.dumps({"content": msg}).encode("utf-8")
          req = urllib.request.Request(webhook, data=data, headers={"Content-Type": "application/json"}, method="POST")
          try:
              urllib.request.urlopen(req, timeout=10).read()
          except Exception as e:
              print(f"WARN: missed-run-check Discord notify failed: {type(e).__name__}: {e}")
              raise SystemExit(0)
          PY
