# Genki BTC Signal — 公開検証アーカイブ

> 投機よりも資本保全を重視するBTC保有者向けの、ルールベースBTC配分シグナルです。

English version: [README.md](./README.md)

---

## このリポジトリの役割

このリポジトリは、Genki BTC Signal の公開証跡アーカイブです。  
Genki BTC Signal は、BTC現物保有者向けの日次リスク管理サービスです。

システムは毎日、市場構造を評価し、現行候補の配分レベルを出力します。

```text
0% / 70% / 100%（strict70_to0_rule_v1 候補。30%ルールは不採用）
```

このリポジトリには、戦略コード・API認証情報・インフラ詳細は含まれません。  
代わりに、誰でも検証できる改ざん検知可能（tamper-evident）な日次ログを公開します。

## なぜこれを公開するのか

多くのBTCシグナルサービスは「意見」を提供します。  
Genki BTC Signal が提供するのは証拠（evidence）です。

ここで公開しているログは、システムの配分判断を結果が確定する前に記録するための公開アーカイブです。各エントリは SHA-256 ハッシュチェーンで前日の記録と暗号学的に連結され、GitHub上のコミット履歴も残ります。

つまり、以下が可能になります。

- 公開後の書き換えを検知できる
- 都合の良い結果だけを抜き出しにくい
- 「当てた」と言うだけで証拠がない状態を避けられる

このサービスを評価する場合、まずここがデューデリジェンス（確認作業）の入口になります。

## このサービスが向いている人

### 感情で判断したくないBTC保有者
BTCの長期的な価値を信じていても、常にフル保有でいるべきか、リスクを落とすべきか、いったん退くべきかの判断は難しいものです。  
このシグナルは、その判断部分をルールベースで補助します。

### チャートを一日中見られない忙しい人
1日1回のシグナルを確認すればよい設計です。  
配分が変わる時だけ対応すればよく、常時監視は不要です。

### 煽りや雰囲気相場に疲れた経験者
インフルエンサーの天井・底打ちコールを見てきた人ほど、必要なのは「雰囲気」ではなく、ルール・ログ・再現性だと分かっています。

このサービスは、短期売買、アルト回転、利益保証を期待する人向けではありません。

## このリポジトリに含まれるもの

| ファイル | 説明 |
|---|---|
| `log.json` | 日次実行ログ（公開・読み取り専用アーカイブ） |

## ログ項目（公開スキーマ）

検証に重要な中核項目（整合性チェック用）:

- `date`
- `timestamp_utc`
- `allocation`
- `prev_hash`
- `hash`
- `updated_at_utc`

運用・補足項目（ロジックバージョンにより変動する場合あり）:

- `btc_price`
- `pnl_btc`
- `position`
- `regime`
- `reason_summary`
- `status`
- `price_source`
- `data_source`
- `day`
- `allocation_changed`
- `notes`
- `logic_version`
- `confidence_score`

このリポジトリには、口座情報、注文ペイロード、APIトークン、環境変数は保存しません。

## 参考パフォーマンス指標

以下の指標は、過去データに対するバックテストから算出した参考値です。  
将来の成績を保証するものではありません。

| 指標 | 値 |
|---|---|
| Final Equity | 15.17x |
| CAGR | 41.02% |
| Max Drawdown | -19.79% |
| Avg Exposure | 11.80% |

現在、実資金によるライブ検証を進行中です。記録はこのアーカイブに蓄積・公開されます。

## ログの検証方法

公開された記録が改ざんされていないことは、誰でも確認できます。

手順1. `log.json` を開き、`entries` 配列を確認する  
手順2. 各エントリの `prev_hash` が、1つ前の `hash` と一致しているか確認する  
手順3. `timestamp_utc` を、このリポジトリのGitコミット履歴と照合する

1行検証コマンド（最新エントリ）:

```bash
python3 -c "
import json, hashlib
j = json.load(open('log.json'))
e = j['latest']
c = {k: v for k, v in e.items() if k not in ('hash', 'prev_hash')}
s = json.dumps(c, ensure_ascii=False, sort_keys=True, separators=(',', ':'))
print(hashlib.sha256((s + '|' + (e.get('prev_hash') or '')).encode()).hexdigest() == e.get('hash'))
"
```

最新エントリのハッシュ整合性が保たれていれば `True` を返します。

### ハッシュ生成ルール

各エントリのハッシュは以下で計算されます。

`SHA-256(canonical_entry_json + "|" + prev_hash)`

先頭エントリでは `prev_hash` の代わりに空文字列を使用します。

## 現在の状況

- Phase: ライブ検証進行中
- Capital deployed: 実資金・限定規模（検証フェーズ）
- Paid access: 検証期間後に提供開始予定 — Waitlistに参加
- Public dashboard: ライブのシグナル状態を見る
- Verification center: 技術検証・再現性センター

検証用の公開アーティファクトは、記録が蓄積されるたびに更新されます。

## 戦略と透明性について

配分ロジック本体は非公開です。  
一方で、「説明どおりに動いている証拠」は公開します。

これは意図的な設計です。実装を保護することと、証拠を隠すことは同じではありません。配分判断は結果が確定する前に記録され、ハッシュチェーンにより改ざんは検知可能です。

これが、私たちが自分たちに課している透明性の基準です。  
必要なら、あなた自身で検証できます。

本資料は投資助言ではありません。過去成績は将来成績を保証しません。最終的な配分判断は各自の責任で行ってください。
