<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BTC SIGNAL</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@500;600;700;800&family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; }
    :root{
      --bg-page: #050608;
      --text-primary: #f2f5fb;
      --text-secondary: #a8b3cf;
      --wait-color: #d79a52;
      --defensive-color: #aeb7c6;
      --bullish-color: #44c27a;
      --strong-bullish-color: #22d39a;
      --wait-glow: rgba(215, 154, 82, 0.16);
      --defensive-glow: rgba(174, 183, 198, 0.14);
      --bullish-glow: rgba(68, 194, 122, 0.15);
      --strong-bullish-glow: rgba(34, 211, 154, 0.16);
      --cta-gold: #d8b24a;
      --cta-gold-hi: #e4c76a;
      --cta-edge: #b98d2f;
      --accent-gold: #d7be73;
      --cta-text: #0b1020;
    }
    body {
      margin: 0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: var(--text-primary);
      background: var(--bg-page);
    }
    .page {
      min-height: 100svh;
      padding: 16px;
      max-width: 420px;
      margin: 0 auto;
    }
    .hero-card {
      background: linear-gradient(180deg, rgba(18,35,73,.95), rgba(10,25,55,.96));
      border: 1px solid rgba(120,165,255,.22);
      border-radius: 22px;
      padding: 22px 18px 18px;
      box-shadow: 0 10px 30px rgba(0,0,0,.24), inset 0 1px 0 rgba(255,255,255,.03);
    }
    .hero-header h1 {
      margin: 0;
      text-align: center;
      font-size: clamp(34px, 8vw, 46px);
      line-height: .95;
      font-weight: 900;
      letter-spacing: .02em;
      color: var(--text-primary);
      font-family: "Space Grotesk", Inter, ui-sans-serif, system-ui, sans-serif;
    }
    .hero-subtitle {
      margin: 10px auto 0;
      max-width: 310px;
      text-align: center;
      font-size: 12px;
      line-height: 1.45;
      color: color-mix(in srgb, var(--text-secondary) 72%, white 28%);
    }
    .action-panel {
      margin-top: 18px;
      min-height: 290px;
      position: relative;
      background: linear-gradient(180deg, rgba(14,28,60,.92), rgba(10,22,49,.94));
      border: 1px solid rgba(100,150,240,.22);
      border-radius: 20px;
      padding: 18px 16px 88px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      justify-content: flex-start;
    }
    .action-panel__label {
      font-size: 12px;
      font-weight: 800;
      letter-spacing: .10em;
      color: rgba(236,243,255,.9);
      text-transform: uppercase;
    }
    .action-panel__body {
      min-height: 150px;
      display: flex;
      align-items: flex-start;
      justify-content: center;
    }
    .action-panel__signal {
      margin-top: 18px;
      font-size: clamp(56px, 15vw, 84px);
      line-height: .88;
      font-weight: 800;
      letter-spacing: -.02em;
      color: var(--wait-color);
      text-shadow: 0 8px 24px var(--wait-glow);
      text-align: center;
      max-width: 100%;
      overflow-wrap: anywhere;
      word-break: break-word;
      text-wrap: balance;
      transform: translate(-2px, 4px);
      font-family: "Space Grotesk", Inter, ui-sans-serif, system-ui, sans-serif;
    }
    .action-panel__signal.state-wait { color: var(--wait-color); }
    .action-panel__signal.state-defensive { color: var(--defensive-color); text-shadow: 0 8px 24px var(--defensive-glow); }
    .action-panel__signal.state-bullish { color: var(--bullish-color); text-shadow: 0 8px 24px var(--bullish-glow); }
    .action-panel__signal.state-strong-bullish { color: var(--strong-bullish-color); text-shadow: 0 8px 24px var(--strong-bullish-glow); }
    .action-panel__reason {
      margin: 0 auto;
      font-size: 12px;
      line-height: 1.35;
      color: rgba(227, 237, 255, .84);
      text-align: center;
      max-width: 88%;
      display: none;
    }
    .action-panel__stale {
      margin: 0 auto;
      font-size: 10px;
      line-height: 1.25;
      color: rgba(255, 209, 120, .92);
      text-transform: uppercase;
      letter-spacing: .06em;
      text-align: center;
      display: none;
    }
    .action-panel__trustPills {
      margin-top: 6px;
      display: flex;
      justify-content: flex-start;
      align-items: center;
      flex-wrap: wrap;
      gap: 6px;
      padding: 0;
      min-height: 22px;
    }
    .trust-pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 999px;
      border: 1px solid rgba(178, 150, 79, .16);
      background: rgba(10,17,34,.08);
      color: rgba(198,210,233,.58);
      white-space: nowrap;
      font-size: 9px;
      font-weight: 700;
      letter-spacing: .03em;
      padding: 4px 8px;
    }
    .action-panel__metaDock {
      position: absolute;
      right: 16px;
      bottom: 12px;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
      max-width: calc(100% - 32px);
    }
    .meta-pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 999px;
      border: 1px solid rgba(176, 145, 72, .24);
      background: rgba(10,17,34,.16);
      color: rgba(228,236,250,.88);
      white-space: nowrap;
    }
    .meta-pill--price {
      padding: 7px 12px;
      font-size: 12px;
      font-weight: 800;
      color: rgba(231, 216, 168, .86);
      font-variant-numeric: tabular-nums lining-nums;
      font-feature-settings: "tnum" 1, "lnum" 1;
    }
    .meta-pill--updated {
      padding: 7px 12px;
      font-size: 12px;
      font-weight: 800;
      color: rgba(237,244,255,.94);
      background: rgba(10,17,34,.22);
      border-color: rgba(190, 205, 240, .30);
      font-variant-numeric: tabular-nums lining-nums;
      font-feature-settings: "tnum" 1, "lnum" 1;
    }
    .hero-bottom {
      margin-top: 14px;
      background: rgba(7,14,30,.55);
      border-radius: 18px;
      padding: 14px 14px 12px;
      display: grid;
      grid-template-columns: minmax(0, 1fr);
      gap: 8px;
      align-items: end;
      overflow: visible;
    }
    .hero-bottom__left {
      width: 100%;
      display: grid;
      justify-items: center;
      text-align: center;
      overflow: visible;
    }
    .live-label {
      font-size: 11px;
      letter-spacing: .14em;
      font-weight: 800;
      color: rgba(235,242,255,.9);
      white-space: nowrap;
      text-transform: uppercase;
    }
    .live-header {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      min-width: 0;
    }
    .live-header__text {
      min-width: 0;
      display: grid;
      gap: 3px;
    }
    .live-avatar {
      width: 28px;
      height: 28px;
      border-radius: 999px;
      object-fit: cover;
      border: 1px solid rgba(180,210,255,.35);
      box-shadow: 0 2px 8px rgba(0,0,0,.28);
      flex: 0 0 auto;
    }
    .live-owner {
      font-size: 11px;
      line-height: 1.2;
      color: rgba(214, 227, 255, 0.72);
      letter-spacing: .02em;
      white-space: nowrap;
    }
    .live-equity {
      font-size: clamp(28px, 7.2vw, 38px);
      line-height: 1.05;
      font-weight: 900;
      letter-spacing: -.015em;
      color: #f5f8ff;
      white-space: nowrap;
      overflow-wrap: normal;
      font-variant-numeric: tabular-nums lining-nums;
      font-feature-settings: "tnum" 1, "lnum" 1;
    }
    .pnl-pct {
      margin-top: 4px;
      font-size: 13px;
      font-weight: 800;
      line-height: 1.35;
      min-height: 1.35em;
      padding-top: 1px;
      display: inline-block;
      position: relative;
      z-index: 1;
      white-space: nowrap;
      font-variant-numeric: tabular-nums lining-nums;
      font-feature-settings: "tnum" 1, "lnum" 1;
    }
    .pnl-pct.positive { color: #34d399; }
    .pnl-pct.negative { color: #f87171; }
    .pnl-pct.flat { color: #94a3b8; }
    .pnl-note {
      margin-top: 2px;
      font-size: 11px;
      color: rgba(214, 227, 255, 0.66);
      letter-spacing: .02em;
      white-space: nowrap;
    }
    .since-start {
      margin-top: 6px;
      font-size: 11px;
      color: rgba(214, 227, 255, 0.72);
      letter-spacing: .02em;
      white-space: nowrap;
    }
    .price-updated {
      margin-top: 4px;
      font-size: 11px;
      color: rgba(214, 227, 255, 0.72);
      letter-spacing: .02em;
      white-space: nowrap;
    }
    .price-updated.warn {
      color: #f3c96b;
    }
    .hero-cta-row {
      margin-top: 14px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 0;
      align-items: center;
    }
    .hero-latest { min-width: 86px; }
    .hero-latest__label {
      font-size: 10px;
      line-height: 1;
      letter-spacing: .12em;
      font-weight: 800;
      color: rgba(236,243,255,.85);
      text-transform: uppercase;
    }
    .hero-latest__date {
      margin-top: 6px;
      font-size: 13px;
      line-height: 1.05;
      font-weight: 900;
      color: #fff;
      white-space: nowrap;
    }
    .hero-cta {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-height: 52px;
      padding: 0 18px;
      border-radius: 999px;
      text-decoration: none;
      font-size: 14px;
      font-weight: 900;
      color: var(--cta-text);
      background: linear-gradient(180deg, var(--cta-gold-hi) 0%, var(--cta-gold) 100%);
      border: 1px solid var(--cta-edge);
      box-shadow: 0 8px 24px rgba(185, 141, 47, .22), inset 0 1px 0 rgba(255, 246, 204, .22);
      white-space: nowrap;
      width: 100%;
    }
    .tabular-nums {
      font-variant-numeric: tabular-nums lining-nums;
      font-feature-settings: "tnum" 1, "lnum" 1;
    }
    .tech-card {
      margin-top: 14px;
      background: linear-gradient(180deg, rgba(12,26,56,.92), rgba(8,20,44,.94));
      border: 1px solid rgba(100,150,240,.2);
      border-radius: 18px;
      padding: 12px;
    }
    .tech-card__toggle {
      width: 100%;
      min-height: 48px;
      border: 1px solid rgba(100,150,240,.18);
      border-radius: 12px;
      background: rgba(8,17,37,.28);
      color: #eef3ff;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 14px;
      font-size: 13px;
      font-weight: 800;
      cursor: pointer;
    }
    .tech-card__content {
      margin-top: 10px;
      overflow-wrap: anywhere;
      word-break: break-word;
    }
    .tech-card__hint {
      border-radius: 12px;
      background: rgba(8,17,37,.2);
      border: 1px dashed rgba(110,160,255,.18);
      padding: 12px;
      text-align: center;
      color: rgba(230,238,255,.72);
      font-size: 12px;
    }
    .audit-grid {
      margin-top: 10px;
      display: grid;
      gap: 8px;
    }
    .audit-section {
      border: 1px solid rgba(110,160,255,.16);
      border-radius: 12px;
      background: rgba(8,17,37,.22);
      padding: 10px;
    }
    .audit-title {
      font-size: 11px;
      font-weight: 800;
      letter-spacing: .08em;
      text-transform: uppercase;
      color: rgba(230,238,255,.88);
      margin-bottom: 8px;
    }
    .audit-row {
      display: grid;
      grid-template-columns: 120px 1fr;
      gap: 8px;
      font-size: 12px;
      color: rgba(230,238,255,.82);
    }
    .audit-row .k { color: rgba(180,200,230,.92); text-transform: uppercase; letter-spacing: .04em; }
    .audit-list {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 6px;
      font-size: 12px;
      color: rgba(230,238,255,.82);
    }
    .proof-code {
      margin-top: 8px;
      border: 1px dashed rgba(110,160,255,.24);
      border-radius: 10px;
      background: rgba(8,17,37,.3);
      padding: 8px;
      font-size: 11px;
      color: rgba(235,242,255,.86);
      overflow-wrap: anywhere;
      word-break: break-word;
      white-space: pre-wrap;
    }
    .proof-summary {
      margin-top: 6px;
      font-size: 12px;
      color: rgba(230,238,255,.78);
    }
    .proof-toggle {
      margin-top: 8px;
      min-height: 32px;
      padding: 0 10px;
      border-radius: 999px;
      border: 1px solid rgba(176, 145, 72, .28);
      background: rgba(248, 232, 164, .08);
      color: rgba(231, 216, 168, .92);
      font-size: 11px;
      font-weight: 700;
      cursor: pointer;
    }
    .proof-copy {
      margin-top: 8px;
      min-height: 34px;
      padding: 0 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,230,140,.45);
      background: rgba(248, 232, 164, .12);
      color: rgba(252,211,77,.92);
      font-size: 12px;
      font-weight: 700;
      cursor: pointer;
    }
    .audit-cta-row {
      margin-top: 10px;
    }
    .audit-cta {
      display: inline-flex;
      width: 100%;
      min-height: 44px;
      align-items: center;
      justify-content: center;
      border-radius: 999px;
      text-decoration: none;
      font-size: 13px;
      font-weight: 800;
      color: rgba(231, 216, 168, .95);
      background: rgba(216, 178, 74, .12);
      border: 1px solid rgba(185, 141, 47, .34);
      box-shadow: inset 0 1px 0 rgba(255, 246, 204, .10);
      white-space: nowrap;
    }

    @media (max-width: 430px) {
      .page { padding: 12px; }
      .hero-card { padding: 18px 14px 14px; }
      .action-panel { min-height: 260px; padding: 16px 14px 84px; }
      .action-panel__signal { font-size: clamp(52px, 14vw, 74px); }
      .action-panel__trustPills { margin-top: 6px; gap: 5px; }
      .trust-pill { font-size: 9px; padding: 4px 8px; }
      .action-panel__metaDock {
        right: 14px;
        bottom: 10px;
        max-width: calc(100% - 28px);
      }
      .hero-bottom { grid-template-columns: minmax(0,1fr); gap: 8px; padding: 12px 12px 10px; }
      .hero-cta-row { grid-template-columns: 1fr; gap: 0; }
      .hero-cta { width: 100%; }
      .audit-row { grid-template-columns: 1fr; gap: 2px; }
    }
  </style>
</head>
<body>
  <main class="page">
    <section class="hero-card">
      <header class="hero-header">
        <h1>BTC SIGNAL</h1>
        <p class="hero-subtitle">Premium BTC risk-control dashboard with full audit transparency.</p>
      </header>

      <section class="action-panel">
        <div class="action-panel__label">GENKI'S LATEST ACTION</div>
        <div class="action-panel__trustPills">
        </div>
        <div class="action-panel__body">
          <div id="actionSignal" class="action-panel__signal">Wait</div>
          <p id="actionReason" class="action-panel__reason">Verification check incomplete. No action taken.</p>
          <p id="dataPending" class="action-panel__stale">Data update pending</p>
        </div>
        <div class="action-panel__metaDock">
          <div id="metaPrice" class="meta-pill meta-pill--price">BTC $67,950.98</div>
          <div id="metaUpdated" class="meta-pill meta-pill--updated">Updated 2026-02-21T15:04:29Z</div>
        </div>
      </section>

      <section class="hero-bottom">
        <div class="hero-bottom__left">
          <div class="live-header">
            <img src="GenkiBTC.jpeg" alt="Genki" class="live-avatar">
            <div class="live-header__text">
              <div id="liveLabel" class="live-label">LIVE TESTING</div>
            </div>
          </div>
          <div id="liveEquity" class="live-equity">-</div>
          <div id="pnlPct" class="pnl-pct" style="display:none"></div>
          <div id="balanceSource" class="pnl-note" style="display:none;">Source: unavailable</div>
          <div id="sinceStart" class="since-start">Since start: -</div>
        </div>
      </section>

      <section class="hero-cta-row">
        <a class="hero-cta" href="sales-page-en.html">Get daily signal by email</a>
      </section>
    </section>

    <section class="tech-card">
      <button class="tech-card__toggle" type="button" onclick="toggleAudit()">Technical Analysis <span id="auditChevron">⌄</span></button>
      <div id="auditContent" class="tech-card__content" style="display:none">
        <div class="audit-grid">
          <div class="audit-section">
            <div class="audit-title">Capital Protection Status</div>
            <div class="audit-row"><div class="k">Status</div><div id="auditChainStatus">-</div></div>
            <div class="audit-row"><div class="k">Core Logic</div><div id="auditLogicVersion">-</div></div>
          </div>
          <div class="audit-section">
            <div class="audit-title">Current Risk Exposure</div>
            <div class="audit-row"><div class="k">Position Status</div><div id="auditAlloc">-</div></div>
            <div class="audit-row"><div class="k">Risk Posture</div><div id="auditTarget">-</div></div>
            <div class="audit-row"><div class="k">Status</div><div id="auditStatus">-</div></div>
            <div class="audit-row"><div class="k">Data Sync</div><div id="auditSnapshot">-</div></div>
          </div>
          <div class="audit-section">
            <div class="audit-title">Recent Verified Decisions</div>
            <ul id="auditRecentList" class="audit-list"><li>-</li></ul>
            <button id="auditRecentMoreBtn" class="proof-toggle" type="button" onclick="showMoreDecisions()" style="display:none; margin-top:8px;">Show more</button>
            <button id="auditRecentCollapseBtn" class="proof-toggle" type="button" onclick="collapseDecisions()" style="display:none; margin-top:8px;">Collapse</button>
          </div>
          <div class="audit-section">
            <div class="audit-title">Proof of Integrity</div>
            <div id="proofSummary" class="proof-summary">Latest proof available • Hash verified record</div>
            <button id="proofToggleBtn" class="proof-toggle" type="button" onclick="toggleProofDetails()">Show raw proof</button>
            <div id="proofCode" class="proof-code" style="display:none">-</div>
            <button id="copyProofBtn" class="proof-copy" type="button" onclick="copyLatestProof()" style="display:none">Copy Latest Proof</button>
          </div>
        </div>
        <div class="audit-cta-row">
          <a class="audit-cta" href="sales-page-en.html">Subscribe for full signal access</a>
        </div>
      </div>
    </section>
  </main>

  <script>
    // Display source map (single-source integrity rules):
    // - Status label: btcsignal_log.json.entries[-1].state -> BTC/CASH
    // - Reason text: btcsignal_log.json.entries[-1].reason
    // - Signal Updated timestamp: log.json.latest.published_at_utc (fallback: updated_at_utc)
    // - LIVE TESTING Day N: TEST_START_DATE_JST + log.json.latest.date
    // - LIVE TESTING equity/P&L: data/live_portfolio_snapshot.json + data/live_test_baseline.json
    const TEST_START_DATE_JST = "2026-02-26";
    const RECENT_INITIAL_COUNT = 10;
    const RECENT_PAGE_INCREMENT = 20;
    let recentVisibleCount = RECENT_INITIAL_COUNT;
    let recentDecisionRows = [];

    function fmtUsd(v) {
      if (v === null || v === undefined || Number.isNaN(Number(v))) return "-";
      return new Intl.NumberFormat("en-US", { style: "currency", currency: "USD", minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(Number(v));
    }

    function fmtNum(v, d=1) {
      if (v === null || v === undefined || Number.isNaN(Number(v))) return "-";
      return Number(v).toFixed(d);
    }

    function fmtUtc(v) {
      if (!v) return "-";
      const d = new Date(v);
      if (!Number.isFinite(d.getTime())) return String(v);
      const y = d.getUTCFullYear();
      const m = String(d.getUTCMonth() + 1).padStart(2, "0");
      const day = String(d.getUTCDate()).padStart(2, "0");
      const hh = String(d.getUTCHours()).padStart(2, "0");
      const mm = String(d.getUTCMinutes()).padStart(2, "0");
      return `${y}-${m}-${day} ${hh}:${mm} UTC`;
    }

    function isIsoDate(v) {
      return typeof v === "string" && /^\d{4}-\d{2}-\d{2}$/.test(v);
    }

    function calcLiveDayN(startDateJst, referenceDateJst) {
      if (!isIsoDate(startDateJst)) return null;
      const startMs = Date.parse(`${startDateJst}T00:00:00+09:00`);
      const refMs = Date.parse(`${referenceDateJst}T00:00:00+09:00`);
      if (!Number.isFinite(startMs) || !Number.isFinite(refMs) || refMs < startMs) return null;
      return Math.floor((refMs - startMs) / 86400000) + 1;
    }

    function getSignalCycleDateJst(latest) {
      const latestDate = toDateOnly(latest?.date);
      if (latestDate) return latestDate;
      const ts = latest?.updated_at_utc || latest?.timestamp_utc || latest?.price_ts;
      if (!ts) return null;
      const d = new Date(ts);
      if (!Number.isFinite(d.getTime())) return null;
      const jst = new Date(d.getTime() + (9 * 60 * 60 * 1000));
      return jst.toISOString().slice(0, 10);
    }

    function parseFiniteNumber(v) {
      if (v === null || v === undefined) return null;
      if (typeof v === "number") return Number.isFinite(v) ? v : null;
      if (typeof v === "string") {
        const t = v.trim();
        if (!t) return null;
        const normalized = t.replace(/[$,%\s]/g, "").replace(/,/g, "");
        const n = Number(normalized);
        return Number.isFinite(n) ? n : null;
      }
      return null;
    }

    function toDateOnly(v) {
      if (!v) return null;
      const s = String(v).trim();
      if (!s) return null;
      const m = s.match(/^(\d{4}-\d{2}-\d{2})/);
      return m ? m[1] : null;
    }


    function mapBtcsignalState(raw) {
      const k = String(raw || "").trim().toUpperCase();
      if (k === "HOLD") return "BTC";
      if (k === "CASH") return "CASH";
      return "unavailable";
    }

    function mapActionClassFromBtState(label) {
      if (label === "BTC") return "state-strong-bullish";
      if (label === "CASH") return "state-wait";
      return "state-wait";
    }

    function mapBtReason(reasonRaw) {
      const r = String(reasonRaw || "").trim();
      if (!r) return "unavailable";
      return r;
    }

    async function fetchBtSignalLog() {
      const res = await fetch(`btcsignal_log.json?ts=${Date.now()}`, { cache: "no-store" });
      if (!res.ok) throw new Error(`btcsignal_${res.status}`);
      return await res.json();
    }

    function buildRecentDecisionRows(btLog) {
      const entries = Array.isArray(btLog?.entries) ? btLog.entries : [];
      return entries
        .map((e) => {
          const date = toDateOnly(e?.date);
          const status = mapBtcsignalState(e?.state);
          const btcPrice = parseFiniteNumber(e?.close);
          return { date, status, btcPrice };
        })
        .filter((r) => !!r.date && r.date >= TEST_START_DATE_JST && r.status !== "unavailable")
        .map((r) => ({
          date: r.date,
          status: r.status,
          btcPriceText: r.btcPrice !== null ? fmtUsd(r.btcPrice) : "unavailable",
        }))
        .reverse();
    }

    function renderRecentDecisions() {
      const list = document.getElementById("auditRecentList");
      const moreBtn = document.getElementById("auditRecentMoreBtn");
      const collapseBtn = document.getElementById("auditRecentCollapseBtn");
      const limit = Math.min(recentVisibleCount, recentDecisionRows.length);
      const rows = recentDecisionRows.slice(0, limit);
      list.innerHTML = rows.length
        ? rows.map((r) => `<li>${r.date} | ${r.status} | BTC ${r.btcPriceText}</li>`).join("")
        : "<li>Unavailable</li>";
      if (moreBtn) {
        moreBtn.style.display = limit < recentDecisionRows.length ? "inline-flex" : "none";
      }
      if (collapseBtn) {
        collapseBtn.style.display = recentDecisionRows.length > RECENT_INITIAL_COUNT && limit > RECENT_INITIAL_COUNT ? "inline-flex" : "none";
      }
    }

    function showMoreDecisions() {
      recentVisibleCount += RECENT_PAGE_INCREMENT;
      renderRecentDecisions();
    }

    function collapseDecisions() {
      recentVisibleCount = RECENT_INITIAL_COUNT;
      renderRecentDecisions();
    }

    function parseDateAny(e) {
      return e?.date_utc || e?.date || "-";
    }

    function normalizeRatio(raw, alloc) {
      const r = Number(raw);
      if (!Number.isNaN(r)) return r;
      const a = Number(alloc);
      if (Number.isNaN(a)) return null;
      return a / 100;
    }

    function actionLabelFromTargetRatio(ratio) {
      const r = Number(ratio);
      if (Number.isNaN(r)) return "Waiting";
      const eps = 0.0001;
      if (Math.abs(r - 0.0) < eps) return "Wait";
      if (Math.abs(r - 0.3) < eps) return "Defensive";
      if (Math.abs(r - 0.7) < eps) return "Bullish";
      if (Math.abs(r - 1.0) < eps) return "Strong Bullish";
      return "Waiting";
    }

    function actionStateClassFromLabel(label) {
      if (label === "Wait") return "state-wait";
      if (label === "Defensive") return "state-defensive";
      if (label === "Bullish") return "state-bullish";
      if (label === "Strong Bullish") return "state-strong-bullish";
      return "state-wait";
    }

    function getBaseEquityDetails(log, startDate = TEST_START_DATE_JST) {
      const latest = log?.latest || {};
      const entries = Array.isArray(log?.entries) ? [...log.entries] : [];
      const candidates = [];

      const latestDate = toDateOnly(latest?.date);
      const latestEq = parseFiniteNumber(latest?.equity_usd);
      if (latestDate && latestEq !== null && latestDate >= startDate) {
        candidates.push({ date: latestDate, value: latestEq, source: "latest.equity_usd" });
      }

      for (const e of entries) {
        const d = toDateOnly(e?.date);
        const eq = parseFiniteNumber(e?.equity_usd);
        if (d && eq !== null && d >= startDate) candidates.push({ date: d, value: eq, source: "entries[].equity_usd" });
      }

      candidates.sort((a, b) => dateSortValue(a.date) - dateSortValue(b.date));
      if (candidates.length) return { value: candidates[0].value, source: candidates[0].source };

      const latestBase = parseFiniteNumber(latest.base_equity);
      if (latestBase !== null) return { value: latestBase, source: "latest.base_equity" };
      return { value: null, source: "none" };
    }

    function getBaseEquity(log) {
      return getBaseEquityDetails(log, TEST_START_DATE_JST).value;
    }

    function getSinceTestStart(log) {
      const start = toDateOnly(log?.start_date_utc);
      if (start) return start;
      const latestStart = toDateOnly(log?.latest?.start_date_utc);
      if (latestStart) return latestStart;
      const entries = Array.isArray(log?.entries) ? log.entries : [];
      const dates = entries.map((e) => toDateOnly(e?.date)).filter(Boolean).sort();
      if (dates.length) return dates[0];
      const latestDate = toDateOnly(log?.latest?.date);
      return latestDate || null;
    }

    function resolveLiveEquityDetails(log, latest) {
      const keys = ["equity_usd", "equity", "portfolio_value", "total_equity_usd"];
      for (const k of keys) {
        const n = parseFiniteNumber(latest?.[k]);
        if (n !== null) return { value: n, source: `latest.${k}` };
      }

      const entries = Array.isArray(log?.entries) ? [...log.entries] : [];
      entries.sort((a, b) => dateSortValue(getEntryDate(b)) - dateSortValue(getEntryDate(a)));
      for (const e of entries) {
        for (const k of keys) {
          const n = parseFiniteNumber(e?.[k]);
          if (n !== null) return { value: n, source: `entries[].${k}` };
        }
      }
      return { value: null, source: "none" };
    }

    function resolvePnlPercent(log, latest, equityFallback = null) {
      const p = parseFiniteNumber(latest?.pnl_percent);
      if (p !== null) return p;
      const eq = parseFiniteNumber(equityFallback ?? latest?.equity_usd);
      const base = parseFiniteNumber(getBaseEquity(log));
      if (eq !== null && base !== null && base > 0) {
        return ((eq - base) / base) * 100;
      }
      return null;
    }

    function mapStatusDisplay(raw, mode = "status") {
      if (raw === null || raw === undefined || raw === "") return "Unavailable";
      const v = String(raw).trim();
      const key = v.toUpperCase();
      if (mode === "integrity" && key === "VALID") return "Verified";
      if (mode === "sync" && key === "SYNCED") return "Synced";
      if (key === "DATA_STALE") return "Safety Hold (Market Data Unstable)";
      if (key === "API_ERROR") return "Risk Isolated (Connection Issue)";
      if (key === "NO_TRADE" || key === "WAIT") return "Awaiting Conditions";
      return v;
    }

    function mapStatusLabelForDecision(raw) {
      if (raw === null || raw === undefined || raw === "") return "UNAVAILABLE";
      const v = String(raw).trim();
      const key = v.toUpperCase();
      if (key === "NO_TRADE" || key === "WAIT" || key === "AWAITING CONDITIONS") return "WAIT";
      if (key === "DATA_STALE" || key === "API_ERROR" || key === "SAFETY HOLD" || key.startsWith("SAFETY HOLD")) return "SAFETY HOLD";
      if (key === "BULLISH") return "BULLISH";
      if (key === "STRONG BULLISH" || key === "STRONG_BULLISH") return "STRONG BULLISH";
      return key;
    }

    function normalizeErrorType(latest) {
      const candidates = [
        latest?.error_type,
        latest?.reason_code,
      ];
      const text = candidates.filter(Boolean).join(" ").toUpperCase();
      if (text.includes("DRYRUN_PRICE_UNAVAILABLE") || text.includes("UNKNOWN_PRICE_STALE")) return "DRYRUN_PRICE_UNAVAILABLE";
      if (text.includes("OPEN_ORDERS_EXIST")) return "OPEN_ORDERS_EXIST";
      if (text.includes("OPEN_ORDERS_CHECK_FAILED")) return "OPEN_ORDERS_CHECK_FAILED";
      if (text.includes("INVALID_STATE")) return "INVALID_STATE";
      return "";
    }

    function normalizeSyncStatus(latest) {
      const sync = String(latest?.snapshot_status || "").toUpperCase();
      if (sync === "SYNC_PENDING") return "SYNC_PENDING";
      if (sync === "SYNCED") return "SYNCED";
      return "";
    }

    function getDisplayReason(statusLabel, errorType, syncStatus, hasData = true) {
      if (!hasData) return "Verification data unavailable. No action taken.";
      const st = String(statusLabel || "").toUpperCase();
      const err = String(errorType || "").toUpperCase();
      if (st === "WAIT") {
        if (err === "DRYRUN_PRICE_UNAVAILABLE") return "Defensive posture due to data instability.";
        if (err === "OPEN_ORDERS_EXIST") return "Defensive posture while existing orders are being verified.";
        if (err === "OPEN_ORDERS_CHECK_FAILED") return "Defensive posture due to exchange verification issue.";
        if (err === "INVALID_STATE") return "Defensive posture due to system state verification.";
        if (String(syncStatus || "").toUpperCase() === "SYNC_PENDING") return "Verification check incomplete. No action taken.";
        return "Criteria not met. No position adjustment.";
      }
      return "Verification check incomplete. No action taken.";
    }

    function runReasonMappingSelfTest() {
      const tests = [
        { input: ["WAIT", "DRYRUN_PRICE_UNAVAILABLE", "", true], expected: "Defensive posture due to data instability." },
        { input: ["WAIT", "OPEN_ORDERS_EXIST", "", true], expected: "Defensive posture while existing orders are being verified." },
        { input: ["WAIT", "OPEN_ORDERS_CHECK_FAILED", "", true], expected: "Defensive posture due to exchange verification issue." },
        { input: ["WAIT", "INVALID_STATE", "", true], expected: "Defensive posture due to system state verification." },
        { input: ["WAIT", "", "SYNC_PENDING", true], expected: "Verification check incomplete. No action taken." },
        { input: ["WAIT", "", "", true], expected: "Criteria not met. No position adjustment." },
        { input: ["WAIT", "", "", false], expected: "Verification data unavailable. No action taken." },
      ];
      const result = tests.map((t) => ({
        input: t.input,
        ok: getDisplayReason(...t.input) === t.expected,
      }));
      console.debug("[REASON_MAPPING_TEST]", result);
    }

    function formatRecentBtcPrice(raw) {
      const p = parseFiniteNumber(raw);
      return p === null ? "BTC N/A" : fmtUsd(p);
    }

    function resolveActualBtcRatio(log, latest) {
      const direct = parseFiniteNumber(latest?.actual_btc_ratio);
      if (direct !== null) return Math.max(0, Math.min(1, direct));

      const snap = parseFiniteNumber(latest?.portfolio_snapshot?.actual_btc_ratio);
      if (snap !== null) return Math.max(0, Math.min(1, snap));

      const entries = Array.isArray(log?.entries) ? log.entries : [];
      for (const e of entries) {
        const r = parseFiniteNumber(e?.actual_btc_ratio);
        if (r !== null) return Math.max(0, Math.min(1, r));
      }

      const pos = String(latest?.actual_position ?? latest?.position ?? "").toUpperCase();
      if (pos === "CASH") return 0;
      return null;
    }

    function formatExposure(value) {
      const n = parseFiniteNumber(value);
      if (n === null) return "Unavailable";
      if (Math.abs(n) < 0.0001) return "0% (Cash)";
      return `${n.toFixed(0)}%`;
    }

    function formatTargetExposure(value) {
      const n = parseFiniteNumber(value);
      if (n === null) return "Unavailable";
      const pct = n <= 1 ? n * 100 : n;
      return `${pct.toFixed(0)}%`;
    }

    function getEntryDate(e) {
      return toDateOnly(e?.date_utc) || toDateOnly(e?.date) || null;
    }

    function dateSortValue(yyyyMmDd) {
      if (!yyyyMmDd) return -Infinity;
      const t = Date.parse(`${yyyyMmDd}T00:00:00Z`);
      return Number.isFinite(t) ? t : -Infinity;
    }

    function renderAudit(log, latest, btLog) {
      document.getElementById("auditChainStatus").textContent = mapStatusDisplay(latest?.chain_integrity, "integrity");
      document.getElementById("auditLogicVersion").textContent = latest?.logic_version ?? "Unavailable";
      document.getElementById("auditAlloc").textContent = "Subscriber-only";
      document.getElementById("auditTarget").textContent = "Capital Protection Active";
      document.getElementById("auditStatus").textContent = mapStatusDisplay(latest?.status, "status");
      document.getElementById("auditSnapshot").textContent = mapStatusDisplay(latest?.snapshot_status, "sync");

      recentVisibleCount = RECENT_INITIAL_COUNT;
      recentDecisionRows = buildRecentDecisionRows(btLog);
      renderRecentDecisions();

      const proof = {
        date: latest?.date ?? "-",
        hash: latest?.hash ?? "-",
        prev_hash: latest?.prev_hash ?? "-",
        status: latest?.status ?? "-",
      };
      document.getElementById("proofCode").textContent = JSON.stringify(proof, null, 2);
      const summary = latest?.hash
        ? "Latest proof available • Hash verified record"
        : "Latest proof unavailable";
      document.getElementById("proofSummary").textContent = summary;
    }

    function copyLatestProof() {
      const txt = document.getElementById("proofCode").textContent || "";
      if (!txt || txt === "-") return;
      navigator.clipboard?.writeText(txt).catch(() => {});
    }

    async function fetchLivePortfolioSnapshot() {
      const res = await fetch(`data/live_portfolio_snapshot.json?ts=${Date.now()}`, { cache: "no-store" });
      if (!res.ok) throw new Error(`snapshot_${res.status}`);
      const j = await res.json();
      return {
        usdtBalance: parseFiniteNumber(j?.usdt_balance),
        btcBalance: parseFiniteNumber(j?.btc_balance),
        updatedAtUtc: j?.updated_at_utc || j?.balance_ts_utc || null,
        source: j?.source || "snapshot",
        status: j?.snapshot_status || null,
        priceAtSnapshot: parseFiniteNumber(j?.price_at_snapshot),
      };
    }

    async function fetchLiveTestBaseline() {
      const res = await fetch(`data/live_test_baseline.json?ts=${Date.now()}`, { cache: "no-store" });
      if (!res.ok) return null;
      const j = await res.json();
      return {
        startDateJst: toDateOnly(j?.start_date_jst || j?.start_date_utc) || TEST_START_DATE_JST,
        equityUsd: parseFiniteNumber(j?.equity_usd),
        usdtBalance: parseFiniteNumber(j?.usdt_balance),
        btcBalance: parseFiniteNumber(j?.btc_balance),
        priceAtBaseline: parseFiniteNumber(j?.price_at_baseline),
        source: j?.source || "BITGET_READONLY",
        createdAtUtc: j?.created_at_utc || null,
      };
    }

    async function fetchLiveBtcPrice() {
      const endpoints = [
        {
          source: "coinbase",
          fetcher: async () => {
            const r = await fetch("https://api.coinbase.com/v2/prices/BTC-USD/spot", { cache: "no-store" });
            if (!r.ok) throw new Error(`coinbase_${r.status}`);
            const j = await r.json();
            const p = parseFiniteNumber(j?.data?.amount);
            if (p === null) throw new Error("coinbase_parse");
            return p;
          }
        },
        {
          source: "kraken",
          fetcher: async () => {
            const r = await fetch("https://api.kraken.com/0/public/Ticker?pair=XBTUSD", { cache: "no-store" });
            if (!r.ok) throw new Error(`kraken_${r.status}`);
            const j = await r.json();
            const p = parseFiniteNumber(j?.result?.XXBTZUSD?.c?.[0]);
            if (p === null) throw new Error("kraken_parse");
            return p;
          }
        }
      ];
      let lastErr = null;
      for (const ep of endpoints) {
        try {
          const price = await ep.fetcher();
          return { price, source: ep.source, fetchedAtUtc: new Date().toISOString() };
        } catch (e) {
          lastErr = e;
        }
      }
      throw lastErr || new Error("price_feed_failed");
    }

    function renderPnlFromBaseline(equity, baseline, snapshotAvailable, snapshotStatus, auditHealthy = true) {
      const pnlEl = document.getElementById("pnlPct");
      const pnlNoteEl = document.getElementById("pnlNote");
      let pnl = null;
      const synced = String(snapshotStatus || "").toUpperCase() === "SYNCED";
      if (auditHealthy && synced && snapshotAvailable && equity !== null) {
        if (!baseline || baseline.equityUsd === null || baseline.equityUsd <= 0) {
          pnl = 0.0;
        } else {
          pnl = ((equity - baseline.equityUsd) / baseline.equityUsd) * 100;
        }
      }
      if (pnl === null || !Number.isFinite(Number(pnl))) {
        pnlEl.textContent = "P/L unavailable";
        pnlEl.style.display = "block";
        if (pnlNoteEl) pnlNoteEl.style.display = "none";
        pnlEl.classList.remove("positive", "negative");
        pnlEl.classList.add("flat");
      } else {
        const val = Number(pnl);
        const sign = val > 0 ? "+" : "";
        pnlEl.textContent = `P/L ${sign}${val.toFixed(2)}%`;
        pnlEl.style.display = "block";
        if (pnlNoteEl) pnlNoteEl.style.display = "block";
        pnlEl.classList.remove("positive", "negative", "flat");
        pnlEl.classList.add(val > 0 ? "positive" : val < 0 ? "negative" : "flat");
      }
    }

    function renderEstimationPriceStatus(tsUtc, delayed = false) {
      const el = document.getElementById("priceUpdated");
      if (!el) return;
      el.textContent = delayed
        ? `Price feed delayed (last update: ${fmtUtc(tsUtc)})`
        : `Price Updated: ${fmtUtc(tsUtc)}`;
      el.classList.toggle("warn", !!delayed);
    }

    function estimateEquityFromPrice(baseEquity, basePrice, btcRatio, livePrice) {
      const be = parseFiniteNumber(baseEquity);
      const bp = parseFiniteNumber(basePrice);
      const br = parseFiniteNumber(btcRatio);
      const lp = parseFiniteNumber(livePrice);
      if (be === null || br === null || lp === null) return null;
      const clamped = Math.max(0, Math.min(1, br));
      if (clamped === 0) return be;
      if (bp === null || bp <= 0) return null;
      const btcUnits = (be * clamped) / bp;
      const cashPart = be * (1 - clamped);
      return cashPart + btcUnits * lp;
    }

    function toggleAudit() {
      const el = document.getElementById("auditContent");
      const chev = document.getElementById("auditChevron");
      const isHidden = el.style.display === "none";
      el.style.display = isHidden ? "block" : "none";
      chev.textContent = isHidden ? "⌃" : "⌄";
    }

    function toggleProofDetails() {
      const proofEl = document.getElementById("proofCode");
      const btn = document.getElementById("proofToggleBtn");
      const copyBtn = document.getElementById("copyProofBtn");
      const isHidden = proofEl.style.display === "none";
      proofEl.style.display = isHidden ? "block" : "none";
      if (copyBtn) copyBtn.style.display = isHidden ? "inline-flex" : "none";
      btn.textContent = isHidden ? "Hide raw proof" : "Show raw proof";
    }

    async function load() {
      const [logRes, btLogRes] = await Promise.all([
        fetch(`log.json?ts=${Date.now()}`, { cache: "no-store" }),
        fetch(`btcsignal_log.json?ts=${Date.now()}`, { cache: "no-store" }),
      ]);
      const log = await logRes.json();
      const btLog = btLogRes.ok ? await btLogRes.json() : { entries: [] };

      const latest = log?.latest || {};
      const btEntries = Array.isArray(btLog?.entries) ? btLog.entries : [];
      const btLatest = btEntries.length ? btEntries[btEntries.length - 1] : {};

      const displayAction = mapBtcsignalState(btLatest?.state);
      const displayReason = mapBtReason(btLatest?.reason);

      const actionEl = document.getElementById("actionSignal");
      actionEl.textContent = displayAction;
      actionEl.classList.remove("state-wait", "state-defensive", "state-bullish", "state-strong-bullish");
      actionEl.classList.add(mapActionClassFromBtState(displayAction));

      const reasonEl = document.getElementById("actionReason");
      if (reasonEl) reasonEl.textContent = displayReason;

      const cycleDate = toDateOnly(latest?.date);
      const signalUpdated = latest?.published_at_utc || latest?.updated_at_utc || "unavailable";
      const basePrice = parseFiniteNumber(latest?.btc_price);
      document.getElementById("metaPrice").textContent = `BTC ${fmtUsd(basePrice)}`;
      document.getElementById("metaUpdated").textContent = `Signal Updated ${fmtUtc(signalUpdated)}`;

      const staleEl = document.getElementById("dataPending");
      if (staleEl) staleEl.style.display = displayAction === "unavailable" ? "block" : "none";

      let snapshot = null;
      try {
        snapshot = await fetchLivePortfolioSnapshot();
      } catch (_) {
        snapshot = null;
      }
      let baseline = null;
      try {
        baseline = await fetchLiveTestBaseline();
      } catch (_) {
        baseline = null;
      }

      const usdt = parseFiniteNumber(snapshot?.usdtBalance);
      const btc = parseFiniteNumber(snapshot?.btcBalance);
      const px = parseFiniteNumber(snapshot?.priceAtSnapshot ?? latest?.btc_price);
      const snapshotAvailable = usdt !== null && btc !== null && px !== null;
      const snapshotStatus = String(snapshot?.status || latest?.snapshot_status || "SYNC_PENDING").toUpperCase();
      const chainIntegrity = String(latest?.chain_integrity || "").toUpperCase();
      const auditHealthy = !chainIntegrity || chainIntegrity === "PASS";
      const snapshotSynced = snapshotStatus === "SYNCED";
      const equity = snapshotAvailable ? (usdt + btc * px) : null;
      document.getElementById("liveEquity").textContent = equity === null ? "-" : fmtUsd(equity);

      const balanceSourceEl = document.getElementById("balanceSource");
      if (balanceSourceEl) {
        const src = snapshotSynced ? String(snapshot?.source || latest?.balance_source || "unavailable") : "unavailable";
        balanceSourceEl.textContent = `Source: ${src}`;
      }

      const sinceStartEl = document.getElementById("sinceStart");
      sinceStartEl.textContent = `Since start: ${baseline?.startDateJst || TEST_START_DATE_JST}`;
      sinceStartEl.style.display = "block";

      const liveLabelEl = document.getElementById("liveLabel");
      const dayN = cycleDate ? calcLiveDayN(TEST_START_DATE_JST, cycleDate) : null;
      liveLabelEl.textContent = dayN ? `LIVE TESTING • Day ${dayN}` : "LIVE TESTING";

      renderPnlFromBaseline(equity, baseline, snapshotAvailable, snapshotStatus, auditHealthy);
      renderAudit(log, latest, btLog);
    }

    runReasonMappingSelfTest();
    load().catch((e) => {
      console.error(e);
      document.getElementById("actionSignal").textContent = "WAIT";
      const reasonEl = document.getElementById("actionReason");
      if (reasonEl) reasonEl.textContent = "Verification data unavailable. No action taken.";
      const staleEl = document.getElementById("dataPending");
      if (staleEl) staleEl.style.display = "none";
    });
  </script>
</body>
</html>
